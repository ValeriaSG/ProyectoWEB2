# Función y expliación del código
## Función del archivo index.html

En este archivo vamos a tener varios elementos que forman parte de neustra interfaz. Ahi se puede ver que se tiene el nombre de la pagina, un apartado llamado carrito que cuenta con un botón de Finalizar compra, otro botón que está debajo del titulo de la página que tiene el nombre de iniciar sesión. 

Tambien vamos a tener los formularios para que el usuario-comprador y el usuario-vendedor puedan acceder a su interfaz de la página. Se cuenta tambien con un panel de administracion y transacciones, esto solo le aparecerá al vendedor cuando inicie sesión y una vez que cierre sesión estos se van a ocultar. 


## Función del archivo Script.js
En nuestro archivo Script.js se puede ver en las primeras lineas de códido que estamos generando y agregando dinamicamente los productos, esto con el objetivo de irlas generando mediante la creación de variables para despues para realizar alguna función.Como se podrá observar se intento ir comentando las lineas del codigo dependiendo de la función que tengan, ya que para evitar confusiones la mayoria del código está comentado y así cualquier problema que se tenga ya se sabe a que linea acudir. 

### Manejo del stock
Aqui se habilita la posibilidad de incluir artículos en el carrito, visualizar los productos dentro del carrito, quitar artículos del carrito y ajustar la disponibilidad de los productos en la lista original en función de las acciones realizadas en el carrito.
La función addToCart posibilita la inclusión de un artículo en el carro de compras. Antes de continuar, verifique si el usuario ha ingresado en su cuenta. De lo contrario, emite una advertencia y detiene la operación. Después, localice el artículo en la lista de productos utilizando su identificación. En caso de haber disponibilidad de stock del producto, se disminuirá la cantidad en la lista original y se agregará al carrito, con la actualización de las vistas de productos y carrito. Se muestra un mensaje informando que el producto está agotado si no hay stock disponible. La tarea de la función updateCart es exhibir los productos presentes en el carrito. En caso de que no haya productos en el carrito, se despliega un aviso y se esconde el botón de compra. En caso de que haya artículos en el carrito, se mostrarán en una lista junto con un botón para eliminar cada uno de ellos. Cuando se quita un artículo, se actualiza tanto el carrito como la lista de productos.
La acción removeFromCart posibilita la eliminación de un artículo del carrito. Al llevar a cabo esta acción, se añade más cantidad de producto a la lista original, se quita el producto del carrito y se actualiza la vista para mostrar la modificación en el stock y en el carrito.
En pocas palabras, estas funciones controlan el carrito de compras para que solo los usuarios autenticados puedan agregar productos y se aseguran de que el stock se mantenga actualizado en la lista de productos y en el carrito del usuario.

### Manejo y control del inicio de sesión del comprador
La tarea de la función fetchUsers es solicitar a través de un método GET al servidor la obtención de todos los usuarios almacenados en la base de datos JSON del servidor. Si la solicitud es exitosa, se recibirán los usuarios en formato JSON; Si no, se gestionará y mostrará un error. Este método se utiliza para verificar si un usuario ya está registrado al intentar registrarse o iniciar sesión. La función de saveUser consiste en manejar el registro de un usuario que se acaba de inscribir. Obtiene los datos de un nuevo usuario, los convierte en formato JSON y los envía al servidor a través de una solicitud POST. Si la operación tiene éxito, se mostrará un mensaje en la consola; De lo contrario, se manejará un error y se alertará al usuario.
El formulario de inscripción (signupForm) se activa al enviarlo, primero verifica si todos los campos están completos antes de revisar si el correo electrónico ya está registrado. Si el usuario ya está registrado, se muestra una alerta. De lo contrario, se crea un nuevo objeto de usuario y se guarda en el servidor usando la función saveUser. Al finalizar, aparece un aviso confirmando el éxito y se alternan entre los formularios de inicio de sesión y registro.
Con respecto al comienzo de sesión, el propósito de loginForm es tomar la información ingresada por el usuario y compararla con la que está almacenada en el servidor utilizando la función fetchUsers. Si se encuentra una coincidencia, el usuario se convierte en currentUser, la interfaz se actualiza con su nombre y se muestra el carrito y los productos disponibles. Si no se encuentra una coincidencia, se generará un mensaje de error.


### Parte del inicio de sesión del vendedor
Se emplea localStorage y un servidor JSON para gestionar los productos en la tienda.
El sellerUsersDb guarda la información de un vendedor, incluyendo su correo electrónico, contraseña y nombre, para autenticación. El valor de isSeller señala si un usuario ha accedido como vendedor. Varios elementos DOM se encargan de gestionar el panel de administración y los formularios relacionados. Al ingresar al vendedor, desaparece el formulario de autenticación y aparece el panel de administración, donde puede agregar productos, revisar la lista y salir. La opción de salir recargar la página para reiniciar la configuración original.
Los artículos son guardados en el localStorage y se renuevan en la interfaz en el panel de administración (donde se pueden editar o borrar productos) y en la página para compradores. La tarea de saveProductsToLocalStorage es almacenar los productos localmente, mientras que displayAdminProducts presenta la lista de productos en el panel de administración. Una vez que el vendedor completa el formulario addProductForm para agregar un producto, los datos son validados y luego enviados al servidor a través de una solicitud POST. Si el producto se agrega correctamente, la lista de productos se actualiza tanto en el almacenamiento local como en la vista pública. La función loadProducts se encarga de cargar los productos desde el servidor JSON al inicio de la página, asegurando que la tienda esté siempre actualizada con los datos más recientes.


### Manejo del carrito utilizando LocalStorage
Primero, la función loadCart carga el carrito del usuario actual desde el localStorage cuando inicia sesión. Si el carrito existe, lo convierte de texto JSON a un arreglo de objetos, y si no, lo inicializa vacío. Esto asegura que cada usuario vea su propio carrito al entrar. Por otro lado, saveCart guarda el carrito actual en el localStorage utilizando el email del usuario como parte de la clave, lo que personaliza el almacenamiento para cada usuario. La función addToCart permite agregar productos al carrito. Antes de hacerlo, verifica que el usuario haya iniciado sesión. Luego busca el producto en la lista general (products), reduce su stock en uno, y lo agrega al carrito con los datos esenciales (id, nombre y precio). Después guarda el carrito actualizado en el localStorage, actualiza la interfaz para reflejar los cambios en el carrito y el stock, y notifica al usuario que el producto fue añadido. Si el producto no tiene stock disponible, muestra una alerta indicando que está agotado.
De forma similar, removeFromCart elimina un producto del carrito. Primero encuentra el producto en la lista del carrito, lo elimina del arreglo con splice, incrementa su stock en la lista general, y guarda el carrito actualizado en el localStorage. Finalmente, refresca la interfaz para mostrar el nuevo estado del carrito y del inventario. Cuando un usuario inicia sesión, se procesa el formulario de inicio (loginForm) buscando las credenciales en una lista de usuarios (fetchUsers). Si son correctas, se carga su carrito con loadCart, se actualizan los elementos visibles en la interfaz (como su nombre y opciones de usuario), y se oculta el formulario de inicio. Por otro lado, al cerrar sesión (logoutButton), se limpia el carrito, se elimina del localStorage, y se regresa a la interfaz inicial donde el formulario de login vuelve a ser visible.


### Finalizar compras con el botón "Finalizar Compra" 
La función finalizePurchase se ejecuta al presionar el botón "Finalizar compra" por parte del usuario. Antes de que nada, asegúrese de que haya un usuario autenticado, currentUser, y de que el carrito no esté sin productos. Cuando se cumplen estas condiciones, se genera un objeto de transacción que contiene el nombre y correo del cliente, los productos en el carrito, y la fecha de hoy. Después, trata de mandar la transacción al servidor local mediante una solicitud POST a la API REST. Si el registro de la transacción es exitoso, se mostrará un mensaje de éxito, se vaciará el carrito y se actualizará la interfaz. En caso de que haya algún error durante esta operación, será detectado y se mostrará un mensaje de error.
La tarea de cargar y visualizar las transacciones en el panel del vendedor recae en la función loadTransactions. La acción solo se lleva a cabo si el usuario ha iniciado sesión como vendedor (isSeller). Esta función envía una solicitud GET a la misma API para recuperar todas las transacciones registradas. Después, borra la información de las transacciones y crea elementos HTML automáticamente para cada una, exhibiendo información como el nombre del cliente, la fecha y los artículos comprados. En caso de que aparezca un error al cargar las transacciones, este será manejado mediante la visualización de un mensaje en la consola.
Al final, una vez que el formulario de inicio de sesión del vendedor haya sido autenticado con éxito, la función loadTransactions será invocada, garantizando que las transacciones se muestrearán automáticamente en el panel administrativo.


### Ocultar elementos y mostrar otros para el vendedor
Cuando se envía el formulario de inicio de sesión de vendedor, se impide el comportamiento estándar con e.preventDefault() y se capturan las credenciales introducidas (correo y contraseña). Después, se comprueba si el correo electrónico está registrado como vendedor en la base de datos (sellerUsersDb) y si la contraseña es correcta. Si se confirma que las credenciales son correctas, se identifica al usuario como vendedor, se muestra un saludo, y se modifica la interfaz: se esconden elementos como el formulario de autenticación de usuarios y el carrito de compras, y se habilitan funciones especiales para vendedores. , como el panel de administración y la lista de transacciones. Asimismo, reciba el nombre de funciones como displayAdminProducts() para exhibir los productos administrables y loadTransactions() para importar las transacciones.
En cambio, al salir de la sesión, el usuario se identifica como no vendedor (isSeller = false), se visualiza un mensaje confirmando el cierre, y se esconden los elementos del panel de control y la lista de transacciones. Por último, se refresca la página con window.location.reload() para restablecer la configuración original y asegurar que los cambios de sesión se muestren correctamente. Este proceso garantiza que solo los vendedores autenticados puedan acceder a las herramientas administrativas y ver las transacciones.

### Eliminar y editar (botones de la lista de productos)
Se añaden, modifican, eliminan y muestran productos en el inventario mediante estas funcionalidades. A continuación, se detallan las características más relevantes. La función saveProductsToLocalStorage guarda la lista de productos en el almacenamiento local del navegador, garantizando la persistencia de los productos tras recargar la página.
La función displayAdminProducts se encarga de presentar la lista de productos en el panel de administración. Cada producto tiene su nombre, precio, stock e imagen desplegada, y se crean opciones para eliminar (deleteProduct) o editar (editProduct) el producto. Al pulsar en el botón "Eliminar", el producto se borra de la lista de productos, seguidamente se modifica el localStorage para reflejar este cambio. Después, se vuelve a mostrar el panel de administración con la lista de productos actualizada.
El administrador puede modificar el nombre, precio y cantidad de un producto usando la función editProduct. Los valores recién solicitados se ingresan a través de un menú desplegable, y si no se proporciona ningún valor, el producto mantendrá su valor original. Después de la edición, el producto se almacena en localStorage y se muestra de nueva la lista de productos actualizada. Mediante el formulario, el administrador puede incluir un producto adicional ingresando el nombre, costo, cantidad en inventario y fotos. Este producto se agrega a la matriz de productos, se guarda en localStorage y actualiza la lista de productos en el panel de administración.
La función displayProducts exhibe los productos en la página principal del comprador, mostrando el nombre, costo, disponibilidad e imagen del producto. También cuenta con un botón para añadir el artículo al carrito. Al cargar la página, los productos se recuperan del localStorage y se presentan en el panel de control y en la página principal para los compradores.

## Función del archivo style.css
En este archivo controlamos todos los aspectos de la apariencia de nuestro sitio web, tales como los colores, fuentes, margenes, tamaños, alineaciones y la disposición de los elementos en la página. 

## Función del archivo data.json
Aqui lo estamos usando para poder almacenar e intercambiar datos, tales como los productos, transacciones y usuarios. Esto nos permite usar un server JSON. 

## Función del archivo server.js
En este caso, se emplea un servidor en Node.js empleando el marco de trabajo Express, diseñado para gestionar las operaciones de un sistema que emplea un archivo JSON (data.json) como base de datos. A continuación, detallo cada segmento del código desde el punto de vista de un alumno de ingeniería informática:
Express va a ofrecer los instrumentos para establecer el servidor y gestionar las rutas HTTP (GET, POST, PUT, DELETE).
Mientras que body-parser facilita el manejo de los datos transmitidos en el contenido de las peticiones HTTP en formato JSON. Despues tendremos a fs (File System), el cual es útil para leer y redactar información en archivos, en este escenario, el archivo data.json. Cors nos facilitará el acceso de otros dominios al servidor, beneficioso para aplicaciones instaladas en diversas plataformas.
Despues vamos a establecer una versión de expres con const app = express() y se determina el puerto en el que operará el servidor (PORT = 3000). Tenemos que app.use(cors()) activa la capacidad de interacción con CORS, lo que posibilita que la página web se comunique con el servidor desde un dominio diferente, mientras que app.use(bodyParser.json()) será el que se encargue de configurar el servidor para que interprete de manera adecuada los datos JSON transmitidos en las peticiones. Despues vamos a usar readData() para poder examinar la información en data.json, la transforma de texto a un objeto JSON y la restituye. Esto se emplea para recopilar la información actual. DataWrite(data) recibe un objeto JSON, lo transforma en texto formateado y lo redacta en data.json, renovando así la base de datos. Herramientas para gestionar operaciones en usuarios, productos y servicios y transacciones.  Ahora vamos a tener que POST/mercancías será el que incorpora un producto novedoso, creando un ID singular, y lo almacena en data.json. Esta parte nos va a permitir eliminar productos retomando su id, ya que anteriormente se presentaban problemas con eso pero al implementar DELETE /products/:id podemos eliminar un producto señalado por su identificación. Refiriendinos a la lista de productos para descartar aquellos que se ajusten al ID proporcionado.
Y finalmente tenemos esta parte que se encargue se inicializar el puerto 3000, de eso se encarga nuestro app.listen(PORT,...) y que cuando el servidor está en funcionamiento, presenta un mensaje en la consola que señala la actividad del servidor localhost3000.




